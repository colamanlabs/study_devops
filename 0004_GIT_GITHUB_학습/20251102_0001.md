
# Git 학습
### 2025.11.02

```
- 팀 개발을 위한 Git, GitHub 시작하기
- ChatGpt
```


## Chapter 0 빠른 실습으로 Git, GitHub 감 익히기


#### 실습 1
```aiignore
git 설정은 전역설정과, 로컬설정(저장소설정)으로 구분된다.
전역설정에 정의했으나, 로컬설정에 재정의 할경우, 로컬설정으로 오버라이드 된다.


전역 설정 (--global, ~/.gitconfig)
저장소 설정 (--local, .git/config)

-- 설정방법 
C:\Users\colaman>
C:\Users\colaman>git config --global user.email "colamanlabs@gmail.com"

C:\Users\colaman>git config --global user.name "colamanlabs"

C:\Users\colaman>
C:\Users\colaman>


-- 확인방법
C:\Users\colaman>git config user.email
colamanlabs@gmail.com

C:\Users\colaman>
C:\Users\colaman>git config user.name
colamanlabs

C:\Users\colaman>
```




#### 실습 2
```aiignore
git add $파일명
git commit -m "메세지내용"
git log

git checkout $COMMIT_ID
git checkout -          // - 는 최신커밋 버전 의미
```

#### 실습 3
```aiignore
"remote add origin" 자체가 하나의 명령이다. 통으로 암기한다.


git status



git remote add origin $REMOTE_URL

git push origin master 

```


#### git push -u origin master 의 의미
```aiignore
-u (또는 --set-upstream) 의 의미

-u 는 “set upstream”, 즉 “현재 로컬 브랜치가 어느 원격 브랜치를 추적할지 설정하라” 라는 뜻입니다.
즉,현재 로컬 브랜치(master)가 원격 저장소(origin)의 master 브랜치를 추적(upstream tracking) 하도록 설정합니다.

이 옵션의 실질적인 효과
이후 git push, git pull 시 브랜치명을 생략 가능

-u를 한 번 지정하면, 그 다음부터는:
git push
git pull
처럼 remote와 branch를 생략해도 됩니다.
왜냐하면, Git이 “아, 이 로컬 브랜치는 origin/master를 추적 중이구나” 하고 자동으로 알게 되기 때문입니다.

# 새 저장소 초기화
git init

# 커밋 생성
git add .
git commit -m "Initial commit"

# 원격 저장소 등록
git remote add origin https://github.com/colamanlabs/myproject.git

# 첫 푸시 (tracking 관계 설정)
git push -u origin master

git push        # OK
git pull        # OK

origin 은 원격저장소명 인데, 재지정을 하지 않으면 기본값으로 origin 을 사용하며, 관례적으로 origin 을 사용한다.
```


#### 실습 4 git clone 
```aiignore

C:\WORKS\WORKS_INTELLIJ_IDEA\WORKSPACE_INTELLIJ_IDEA_GITHUB\temp>git clone https://github.com/colamanlabs/study_java_2025.git
Cloning into 'study_java_2025'...
remote: Enumerating objects: 213, done.
remote: Counting objects: 100% (213/213), done.
remote: Compressing objects: 100% (136/136), done.
remote: Total 213 (delta 37), reused 0 (delta 0), pack-reused 0 (from 0)
Receiving objects: 100% (213/213), 912.11 KiB | 16.00 MiB/s, done.
Resolving deltas: 100% (37/37), done.

C:\WORKS\WORKS_INTELLIJ_IDEA\WORKSPACE_INTELLIJ_IDEA_GITHUB\temp>
```

#### git pull
```aiignore
git pull <원격저장소명> <브랜치명>

git pull origin master

“원격 저장소(origin)의 master 브랜치에서 변경 사항을 가져와(fetch) 
현재 체크아웃된 로컬 브랜치에 병합(merge)하라.”

🔹 내부적으로는 두 단계로 동작

git pull 은 사실상 다음 두 명령을 자동으로 연속 실행하는 것과 같습니다.

단계	실제 수행 명령	설명
①	git fetch origin master	원격 저장소(origin)의 master 브랜치 내용을 가져옴 (단, 병합은 하지 않음)
②	git merge origin/master	가져온 변경 내용을 현재 로컬 브랜치와 병합
즉, git pull = fetch + merge 입니다.


실행 후의 결과
원격 저장소 origin 의 master 브랜치 최신 커밋들을 가져와
로컬의 origin/master (원격 추적 브랜치)에 저장합니다.

그다음, 현재 체크아웃된 로컬 브랜치(예: master)에 이를 병합합니다.

🔹 만약 -u 로 추적 관계가 이미 설정되어 있다면
처음에 아래 명령을 실행했다면:
git push -u origin master

이제 Git은 로컬 master ↔ 원격 origin/master 가 연결된 상태입니다.
따라서 이후에는 이렇게 간단히 써도 됩니다:
git pull

→ Git이 자동으로 “origin의 master”를 추적하고 있다는 걸 알고 있기 때문입니다.
```


#### pull 대신 fetch + merge 를 직접 쓰는 이유 (실무 팁)
```aiignore
🔹 pull 대신 fetch + merge 를 직접 쓰는 이유 (실무 팁)

실무에서는 다음처럼 분리해서 쓰는 경우가 많습니다 👇

git fetch origin
git merge origin/master

이유는?
git fetch 로 변경 내용을 먼저 확인할 수 있음
바로 병합하지 않고, 코드 리뷰나 diff 확인 후 merge 가능
git pull 은 자동으로 merge 해버려서 예기치 않은 충돌이 발생할 수도 있음

💡 비유로 이해하기
git fetch = “서버에서 최신 파일을 받아오기만 한다.”
git merge = “받아온 내용을 내 폴더에 합친다.”
git pull = “받아오고(fetch), 바로 합쳐라(merge).”
```

### -- 끝 --


